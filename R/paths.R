#' Split a path into its components
#' 
#' \code{decompose_path} splits a path into the directory name, filename 
#' without extension, and extension. \code{strip_extension} and 
#' \code{get_extension} provide shortcuts to the second and third parts
#' of the filename. \code{recompose_path} takes the result of 
#' \code{decompose_path} and returns complete paths.
#' @param x A character vector of file paths. Defaults to files in the 
#' current directory.
#' @param include_dir Should the directory part of the path be included?
#' @param new_extension A new extension to replace the existing ones.
#' @param ... Not currently used.
#' @return \code{decompose_path} returns a character matrix with three 
#' columns named \code{"dirname"}, \code{"filename"} and \code{"extension"}.
#' \code{strip_extension} returns a character vector of the second column,
#' and \code{get_extension} returns a character vector of the third column.
#' \code{recompose_path} returns a character vector of paths.
#' @examples
#' x <- c(
#'   "somedir/foo.tgz",         # single extension
#'   "another dir\\bar.tar.gz", # double extension
#'   "baz",                     # no extension
#'   "quux. quuux.tbz2",        # single ext, dots in filename
#'   R.home(),                  # a dir
#'   "~",                       # another dir
#'   "~/quuuux.tar.xz",         # a file in a dir
#'   "",                        # empty 
#'   ".",                       # current dir
#'   "..",                      # parent dir
#'   NA_character_              # missing
#' )
#' (decomposed <- decompose_path(x))
#' get_extension(x)
#' strip_extension(x)
#' strip_extension(x, FALSE)
#' recompose_path(decomposed)
#' @export
decompose_path <- function(x = dir())
{
  if(assertive::is_empty(x))
  {
    return(
      structure(
        data.frame(
          dirname = character(), 
          filename = character(), 
          extension = character(),
          stringsAsFactors = FALSE
        ),
        class = c("decomposed_path", "data.frame")
      )
    )
  }
  original_x <- x <- assertive::coerce_to(x, "character")
  x <- standardize_path(x)
  not_missing <- assertive::is_not_na(x)
  is_dir_x <- assertive::is_dir(x)
  
  basename_x <- ifelse(
    not_missing,
    ifelse(is_dir_x, "", basename(x)),
    NA_character_
  )
  has_extension <- stringr::str_detect(basename_x, stringr::fixed("."))
    
  # match one or more letters, numbers and allowed punctuation characters
  # (the filename without extension)
  # then a single period
  # then match one of more letters numbers and periods
  # (the file extension)
  rx <- "^([][[:alnum:] `!@#$%^&()_=+{},.;'-]+?)\\.([[:alnum:].]+)$"
  split_name <- stringr::str_match(
    basename_x[not_missing & has_extension], 
    rx
  )

  filename_x <- ifelse(not_missing, basename_x, NA_character_)
  if (!is_empty) {
    filename_x[not_missing & has_extension] <- split_name[, 2L]
  }
  extension_x <- ifelse(not_missing, "", NA_character_)
  if (!is_empty) {
    extension_x[not_missing & has_extension] <- split_name[, 3L]
  }
  
  decomposed_x <- data.frame(
    dirname   = ifelse(
      not_missing,
      ifelse(is_dir_x, x, dirname(x)), 
      NA_character_
    ),
    filename  = filename_x, 
    extension = extension_x,
    row.names = ifelse(is.na(original_x), "<NA>", original_x),
    stringsAsFactors = FALSE
  )
  
  structure(decomposed_x, class = c("decomposed_path", "data.frame"))
}

#' Copy the contents of a directory
#'
#' Copies the contents of a directory, possibly recursively.
#' @param source_dir String of directory to copy from.
#' @param target_dir String of directory to copy to.
#' @param pattern String regex or \code{NULL}. A filter for filenames, passed
#' to \code{dir}.
#' @param overwrite Logical value. Should existing files be overwritten?
#' @param recursive Logical value. Should subdirectories and their contents
#' be copied?
#' @note Target directories that don't exist are created, silently (assuming
#' write permission).
#' @return A logical vector of whether or not each file was successfully
#' copied is invisibly returned.
#' @seealso \code{\link[base]{basename}}
#' @examples
#' \dontrun{
#' #Copy subdirs by default
#' dir_copy(R.home("etc"), file.path(tempdir(), "etc"))
#' #Just copy the top level
#' dir_copy(R.home("etc"), file.path(tempdir(), "etc2"), recursive = FALSE)
#' #Now copy deeper levels, without overwriting.
#' dir_copy(R.home("etc"), file.path(tempdir(), "etc2"), overwrite = FALSE)
#' #Cleanup
#' unlink(file.path(tempdir(), "etc"), recursive = TRUE)
#' unlink(file.path(tempdir(), "etc2"), recursive = TRUE)
#' }
#' @export
dir_copy <- function(source_dir, target_dir, pattern = NULL, overwrite = FALSE,
  recursive = TRUE)
{
  #Retrieve all file and directory names
  filenames <- dir(
    source_dir,
    pattern = pattern,
    recursive = recursive,
    all.files = TRUE,
    full.names = FALSE,
    include.dirs = TRUE
  )
  
  #Create missing directories, silently.
  is_directory <- assertive::is_dir(file.path(source_dir, filenames))
  directories <- c(target_dir, file.path(target_dir, filenames[is_directory]))
  plyr::tryapply(
    directories,
    dir.create,
    showWarnings = FALSE,
    recursive = recursive
  )
 
  out_dir <- file.path(target_dir, dirname(filenames[!is_directory]))
  out_dir <- gsub("/\\.$", "", out_dir)
  
  if(length(out_dir) == 0) return()
  ok <- mapply(
    file.copy,
    from = file.path(source_dir, filenames[!is_directory]),
    to = out_dir,
    overwrite = overwrite,
    recursive = FALSE
  )
  if(!all(ok))
  {
    warning(
      "The files ",
      toString(sQuote(filenames[!ok])),
      " were not copied successfully."
    )
  }
  names(ok) <- filenames[!is_directory]
  invisible(ok)
}

#' @rdname dir_copy
#' @export
dir_copy_rappster <- function(source_dir, target_dir, pattern = NULL, overwrite = FALSE, 
  recursive = TRUE)
{
    .file.copy <- function(source_dir, target_dir, overwrite, recursive) {
        if (!file.exists(target_dir)) {
            dir.create(target_dir, showWarnings=FALSE, recursive=TRUE)
        }

        out <- withRestarts(
            {
                wd_0 <- setwd(source_dir)     
                from_this <- "."
                if (!recursive) {
                    from_this <- list.files(from_this)
                }     
                tmp <- sapply(from_this, file.copy, to=target_dir, 
                    overwrite=overwrite, recursive=recursive)  
                if (!recursive) {
                    ## Directory candidates //
                    dir_cands <- names(tmp[!tmp])
                    if (length(dir_cands)) {
                        dirs <- dir_cands[idx <- which(file.info(dir_cands)$isdir)]
                        if (length(dirs)) {
                        ## Create empty directories //
                            lapply(file.path(target_dir, dirs), 
                                dir.create, showWarnings=FALSE)
                            tmp[dir_cands[idx]] <- TRUE
                        }
                    }
                }
                setwd(wd_0)
                if (!all(tmp)) {
                    warning(
                        "The files ",
                        toString(sQuote(names(tmp[!tmp]))),
                        " were not copied successfully."
                    )
                }
                out <- list(from=source_dir, to=target_dir, elements=tmp)
            },
            warning=function(cond) {
                setwd(wd_0)
                warning(cond)
                invokeRestart("muffleWarning")
            },
            error=function(cond) {
                setwd(wd_0)
                stop(cond)
            }
        )
        out 
    }            
    out <- mapply(
      .file.copy,
      source_dir=source_dir, 
      target_dir=target_dir,
      overwrite=overwrite, 
      recursive=recursive,
      SIMPLIFY=FALSE,
      USE.NAMES=FALSE
    )
    invisible(out)
}

#' @rdname decompose_path
#' @export
get_extension <- function(x = dir())
{
  decompose_path(x)[, 3L]
}

#' @rdname decompose_path
#' @export
recompose_path <- function(x, ...)
{
  UseMethod("recompose_path")
}

#' @rdname decompose_path
#' @export
recompose_path <- function(x, ...)
{
  UseMethod("recompose_path")
}

#' @rdname decompose_path
#' @method recompose_path decomposed_path
#' @export
recompose_path.decomposed_path <- function(x, ...)
{
  not_missing <- assertive::is_not_na(x[, "filename"])
  has_an_extension <- nzchar(as.character(x[not_missing, "extension"]))
  path <- rep.int(NA_character_, nrow(x))
  base_x <- ifelse(
    has_an_extension,
    paste(x[not_missing, "filename"], x[not_missing, "extension"], sep = "."),
    x[not_missing, "filename"]
  )
  path[not_missing] <- file.path(x[not_missing, "dirname"], base_x)
  path
}

#' @rdname decompose_path
#' @export
recompose_path_rappster <- function(x, ...)
{
  UseMethod("recompose_path_rappster")
}

#' @rdname decompose_path
#' @method recompose_path decomposed_path
#' @export
recompose_path_rappster.decomposed_path <- function(x, use_shortform=FALSE, ...)
{
  not_missing <- assertive::is_not_na(x[, "filename"])
  has_dirpath <- nzchar(x[not_missing, "dirname"])
  has_an_extension <- nzchar(as.character(x[not_missing, "extension"]))
  path <- rep.int(NA_character_, nrow(x))
  base_x <- ifelse(
    has_an_extension,
    paste(x[not_missing, "filename"], x[not_missing, "extension"], sep = "."),
    x[not_missing, "filename"]
  )
  has_base <- nzchar(base_x)
#  path[not_missing] <- file.path(x[not_missing, "dirname"], base_x)
    
  #########
  # Patch #
  #########
  path[not_missing] <- ifelse(
        has_base,
        file.path(x[not_missing, "dirname"], base_x),
        ifelse(
            has_dirpath,
            x[not_missing, "dirname"],
            ""
        )
    )
    
    if (use_shortform) {
        path[which(path == getwd())] <- "."
        path[which(path == dirname(getwd()))] <- ".."
        path <- gsub(paste0("^", getwd(), "/"), "", path)
        path <- gsub(paste0("^", normalizePath(path.expand("~"), winslash="/"), "/"), "~/", path)
    }
  path
}

#' @rdname decompose_path
#' @export
replace_extension <- function(x = dir(), new_extension)
{
  paste(strip_extension(x), new_extension, sep = ".")
}

#' Standardize paths
#' 
#' Standardi[sz]e path names so that they can be more easily compared.
#' @param x A character vector of paths.
#' @param sep String separator betwen directory levels in the output.
#' @return A character vector of paths, pointing to the same locations as the
#' input, but in a standardized form.
#' @seealso \code{\link[base]{normalizePath}}, \code{\link[base]{path.expand}}
#' @examples
#' standardize_path(c(".", "..", "~", R.home(), NA))
#' standardize_path(c(".", "..", "~", R.home(), NA), "\\")
#' @export
standardize_path <- function(x = dir(), sep = c("/", "\\"))
{
  if(assertive::is_empty(x))
  {
    return(character())
  }
  sep <- match.arg(sep)
  ifelse(
    is.na(x),
    NA_character_,
    normalizePath(path.expand(x), sep, FALSE)
  )
}

#' @rdname standardize_path
#' @export
standardise_path <- standardize_path

#' @rdname decompose_path
#' @export
strip_extension <- function(x = dir(), include_dir = TRUE)
{
  decomposed <- decompose_path(x)
  if(include_dir) 
  {
    ifelse(
      is.na(x),
      NA_character_,
      file.path(decomposed[, 1L], decomposed[, 2L])
    )
  } else
  {
    decomposed[, 2L]
  }
}
